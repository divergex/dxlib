from typing import List

from .history import History
from .strategy import Strategy


class Executor:
    """
    An executor is a history factory that creates histories from a schema.
    It receives an output schema and a data source, either a:

    - Generator + input schema;
    - AsyncGenerator + input schema;
    - or Sync History class.

    And a strategy that will generate the output data.

    The executor then returns a History object with the output schema, given the output generated by the strategy.
    This can be used for backtesting, optim, paper trading and live trading.
    """
    def __init__(self, strategy: Strategy):
        self.strategy = strategy

    def run(self, obj: History | List[History], groupby: List[str] | str | None = None):
        """
        Runs the executor in Sync mode.

        Args:

        Returns:
            History: The output history.
        """
        if isinstance(obj, History):
            return self._run_history(obj, groupby)
        elif isinstance(obj, list):
            return [self._run_history(history, groupby) for history in obj]
        else:
            raise NotImplementedError

    def _run_history(self, obj: History, groupby: List[str] | str | None = None):
        """
        Runs the executor in Sync mode.

        Args:

        Returns:
            History: The output history.
        """
        # First, group by first element of groupby in the index
        # example: Multiindex with 5 levels, groupby=["level4", "level2"] will group by level 4,
        # get __next__, then group by level 2, then get __next__, then execute strategy
        if isinstance(groupby, list):
            groupby = [obj.idx(group) for group in groupby]
        elif isinstance(groupby, str):
            groupby = [obj.idx(groupby)]
        else:
            # first level
            groupby = [0]

        result = History(schema=self.strategy.output_schema)

        for level in groupby:
            grouped = obj.data.groupby(level=level)
            for group_idx, observation in grouped:
                observation = obj.get({obj.iidx(level): group_idx})
                # use obj.get_slice to get all data that happened up until the current observation: no look-forward bias
                history = obj.get({obj.iidx(level): slice(None, group_idx)})
                output = self.strategy(observation, history)
                result.add(output)

        # Assuming you'd want to return some result or modified data
        return result

